% NOTES FROM DESIGN %

% Mininet
% virtual Network
% custom toppologies
% modelling fgpa smart switches
% distinction between FPGA-based smart network switches  and regular

% initially, just do regular

% iterative design, so system should always be working, and one feature was added at a time, along with tests

% key features were...

% talk about pylint, integrated with pycharm

% travis?

% poisson feature

% git submodules
  % talk about how you thought about including the code from mininet, and keeping it up to date
  % YOU HAVEN'T MENTIONED SUBMODULES ANYWHERE ELSE!
  % talk about how mininet is developed in git on github

  % the same approach could be used for other shit in future

% I thought about documentation,
  % Readme was sufficient

% click vs argparse

% logging

% NOTES FROM DESIGN %
% ----------------------------

% Initially, no options.
%   Based off Mininet example.
%   Simple Mininet tree Topology
%   Essentially a Mininet wrapper
%   git submodule
%   .gitignore
%
%
% Then added structure
%   Readme?
%   argument parsing
%     argparse vs click
%   travis structure
%
%
% logging
%   json config
%
%
% performance tests
%   custom cloud test
%   mininet tests
%
%
% further options
%   spread
%   depth
%   bandwidth
%   delay
%   loss
%   fpga
%   fpga-bandwidth
%   fpga-delay
%   fpga-loss
%   ping-all
%   iperf
%   cloud-fpga
%   dump-node-connections
%   poisson
%   log
%
% user testing?

\section{Initial System}
\label{initial_system}
% Initially, no options.
%   Based off Mininet example.
%   Simple Mininet tree Topology
%   Essentially a Mininet wrapper
%   git submodule
%   .gitignore
The system was initially implemented as a wrapper for the \textit{Mininet} API.
This would utilise the relevant features of the API, while restricting access to those which were not relevant to the system.
This involved declaring \textit{Mininet} as a \textit{git submodule} of the system, as discussed in section \ref{dependencies}.
The implemented features of the \textit{Mininet} API were a simple tree topology, and a network test built into the API which would confirm all hosts in the topology could communicate with one another.
Once these had been implemented, running the system would:

\begin{enumerate}
  \item Initialise the network
  \item Create the required switches
  \item Create the required hosts
  \item Create the required links between switches and other switches, and between switches and hosts
  \item Run the network test and display the results
  \item Break down the network
\end{enumerate}

\section{System Structure}
\label{system_structure}
% Then added structure
%   Readme?
%   argument parsing
%     argparse vs click
%   travis structure
%

With the core functionality in place, structure could now be added to the system to allow additional features to be added in a sustainable and efficient way.
% Write some more here

\subsection{User Customisation}
\label{user_customisation}
For command line applications such as this one, customisation is commonly performed through either configuration files, or through arguments specified at the command line.
For this system, command line arguments were deemed more appropriate, since they allow for a simpler user experience, while still providing a high level of flexibility.
The \textit{Python} library \textit{Click} \cite{python_click} was used to implement these arguments.
\textit{Click} was chosen since it allows for a large amount customisation of the system's arguments.
By default, \textit{Click} configures the `--help' flag, which will print out a formatted list of all available flags and arguments for the system, along with the type of data they expect and any explanatory messages associated with each flag or argument.
For each flag or argument, the type can be configured, as can the explanatory message, and the name of the flag or argument.
A default value can also be set, and custom restrictions can be placed on the type of data accepted by each flag or argument.

\subsection{Documentation}
\label{documentation}
Suitable documentation was required to ensure the usability of the system.
A separate user guide was considered, however it was concluded that this was unnecessary, due to the straightforward nature of the command line interface.
Instead, a `Readme' file was written in \textit{Markdown} \cite{markdown} and added to the \textit{GitHub} repository for the system where it would be formatted and clearly displayed.
% More

\subsection{Testing Structure}
\label{testing_structure}
% \textit{Travis CI} \cite{travis_ci} was used to conduct many of the tests in the system.
\textit{Travis CI} \cite{travis_ci} is a web-based CI platform designed for running automated tests, and this was used to conduct many of the tests in the system.
The testing process itself is discussed in detail in section \ref{testing}.
However, prior to tests being written, \textit{Travis CI} needed to be configured to automatically run tests on change it detected in \textit{GitHub}.
To do this, a \textit{YAML} configuration file for \textit{Travis CI} was added to the code.
A directory was also created for tests to be added to.

\section{Feature Implementation}
\label{features}

\subsection{Logging}
\label{logging}
%   log
%   dump-node-connections

\subsection{Performance Tests}
\label{performance_tests}
% performance tests
%   custom cloud test
  %   cloud-fpga
%   mininet tests
  %   ping-all
  %   iperf

%
\subsection{Network Topology Customisation}
\label{network_topology_customisation}
% further options
%   spread
%   depth

\subsection{Network Performance Customisation}
\label{network_performance_customisation}

%   bandwidth
%   delay
%   loss

%   poisson

\subsection{FPGA-Based Smart Network Switch Customisations}
\label{FPGA_Based_Smart_Network_Switch_Customisations}

%   fpga
%   fpga-bandwidth
%   fpga-delay
%   fpga-loss

% \section{response to user testing?}
